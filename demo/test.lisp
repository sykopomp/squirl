(defpackage #:squirl-demo
  (:use :cl :uid :squirl :sheeple)
  (:export :run-demo))
(in-package :squirl-demo)

(defparameter *fps-sample-size* 5)
(let (last-frame
      (fps-stack)
      (frames 0)
      (cumulative-mean 0))
  (defun notify-frame ()
    (when (> (length fps-stack) *fps-sample-size*)
      (setf (cdr (last fps-stack 2)) nil))
    (let ((now (now)))
      (when last-frame
        (let ((time-delta (- now last-frame)))
          (unless (zerop time-delta)
            (push (/ time-delta)
                  fps-stack)
            (setf cumulative-mean (/ (+ (last-fps)
                                        (* frames cumulative-mean))
                                     (1+ frames)))
            (incf frames))))
      (setf last-frame now)))
  (defun last-fps ()
    (first fps-stack))
  (defun mean-fps ()
    (when fps-stack
      (/ (reduce #'+ fps-stack) (length fps-stack))))
  (defun cumulative-mean-fps ()
    cumulative-mean)
  (defun reset-cumulative-mean-fps ()
    "Restart calculating the cumulative mean relative to the current frame."
    (setf frames 0)
    (setf cumulative-mean 0)))

(defproto =squirl-demo= (=engine=)
  ((title "Demo for SquirL")
   (window-width 500)
   (window-height 500)
   (world nil)
   (accumulator 0)
   (physics-timestep (float 1/60 1d0))
   (shape-dimension 30d0)
   (shape-dimension-increment 10)
   (current-view (create-view 0 0 500 500))
   (mouse-body (make-body))
   (mouse-joint nil)
   (mouse-point-last +zero-vector+)))

(defun draw-a-circle (circle)
  (let* ((position (body-position circle))
         (x (vec-x position))
         (y (vec-y position)))
    (draw-circle (make-point x y) 15 :resolution 30)))

(defun draw-body (body)
  (let* ((position (body-position body))
         (x (vec-x position))
         (y (vec-y position)))
    (with-color *green*
      (map nil #'draw-shape (body-shapes body)))
    (draw-circle (make-point x y) 2 :resolution 30 :color *red*)))

(defreply init :after ((demo =squirl-demo=))
  (setf (world demo) (make-world :gravity (vec 0 -300)))
  (let ((body (make-body :position (vec 250 60)))
        (floor (make-segment (vec -200 0) (vec 200 0)
                             :restitution 1 :friction 1 :radius 3))
        (left-wall (make-segment (vec -200 0) (vec -200 200)
                                 :restitution 1 :friction 1 :radius 3))
        (right-wall (make-segment (vec 200 0) (vec 200 200)
                                  :restitution 1 :friction 1 :radius 3)))
    (mapc (lambda (_) (attach-shape _ body))
          (list floor left-wall right-wall))
    (world-add-body (world demo) body)))

(defun draw-constraint (constraint)
  (let* ((body-a (constraint-body-a constraint))
         (body-b-pos (body-local->world (constraint-body-b constraint)
                                        (squirl::pivot-joint-anchor2 constraint))))
    (with-color *green*
      (draw-circle (make-point (vec-x (body-position body-a))
                               (vec-y (body-position body-a)))
                   5 :resolution 10)
      (draw-circle (make-point (vec-x body-b-pos)
                               (vec-y body-b-pos))
                   5 :resolution 10))))

(defgeneric draw-shape (shape)
  (:method ((circle circle))
    (let* ((circle-center (circle-transformed-center circle))
           (edge (vec* (body-rotation (shape-body circle))
                       (circle-radius circle)))
           (edge-t (vec+ edge circle-center))
           (edge-neg-t (vec- circle-center edge)))
      (draw-circle (make-point (vec-x circle-center) (vec-y circle-center))
                   (round (circle-radius circle)) :filledp nil)
      (draw-line (make-point (vec-x edge-t) (vec-y edge-t))
                 (make-point (vec-x edge-neg-t) (vec-y edge-neg-t)))))
  (:method ((seg segment))
    (let ((a (segment-trans-a seg))
          (b (segment-trans-b seg)))
      (draw-line (make-point (vec-x a) (vec-y a))
                 (make-point (vec-x b) (vec-y b)))))
  (:method ((poly poly))
    (let ((vertices (poly-transformed-vertices poly)))
      (loop for i below (length vertices)
         for a = (elt vertices i)
         for b = (elt vertices (mod (1+ i) (length vertices)))
         do (draw-line (make-point (vec-x a) (vec-y a))
                       (make-point (vec-x b) (vec-y b)))))))

(defun draw-scale (length x y)
  (let ((left (make-point (- x (/ length 2)) y))
        (right (make-point (+ x (/ length 2)) y))
        (half-edge-height 2))
    (draw-line left right :color *red*)
    (draw-line (make-point (point-x left)
                           (- (point-y left) half-edge-height))
               (make-point (point-x left)
                           (+ (point-y left) half-edge-height))
               :color *blue*)
    (draw-line (make-point (point-x right)
                           (- (point-y left) half-edge-height))
               (make-point (point-x right)
                           (+ (point-y left) half-edge-height))
               :color *blue*)))

(defreply draw ((demo =squirl-demo=) &key)
  (format t "FPS: ~7,2f/~7,2f/~7,2f~%"
          (last-fps)
          (mean-fps)
          (cumulative-mean-fps))
  (map-world #'draw-body (world demo))
  (map nil #'draw-constraint (world-constraints (world demo)))
  (draw-scale (shape-dimension demo) (mouse-x demo) (mouse-y demo)))

;; This allows us to fix the physics timestep without fixing the framerate.
;; This means the physics -should- run at the same perceived speed no matter
;; how fast your computer's calculating :)
(defreply update ((demo =squirl-demo=) dt &key)
  (notify-frame)
  (let ((new-point (vec-lerp (mouse-point-last demo) (vec (mouse-x demo) (mouse-y demo)) 1/4)))
    (setf (body-position (mouse-body demo)) new-point
          (body-velocity (mouse-body demo)) (vec* (vec- new-point (mouse-point-last demo)) 60d0)
          (mouse-point-last demo) new-point))
  (update-world-state demo dt)
  (empty-out-bottomless-pit (world demo)))

(defun update-world-state (demo dt)
  (incf (accumulator demo) (if (> dt 0.5) 0.5 dt))
  (loop while (>= (accumulator demo) (physics-timestep demo))
     do (world-step (world demo) (physics-timestep demo))
        (decf (accumulator demo) (physics-timestep demo)))
  (when (key-down-p #\c)
    (add-circle demo (mouse-x demo) (mouse-y demo)))
  (when (key-down-p #\s)
    (add-poly demo (mouse-x demo) (mouse-y demo))))

(defun empty-out-bottomless-pit (world)
  "Get rid of any bodies that have fallen into the bottomless pit."
  (map nil (lambda (c) (world-remove-body world c))
       (remove-if (lambda (c) (> (vec-y (body-position c)) -100))
                  (world-bodies world))))

(defun add-circle (demo x y)
  (let* ((radius (/ (shape-dimension demo) 2))
         (mass (* pi radius radius))
         (inertia (moment-for-circle mass 0 radius (vec 0 0)))
         (body (make-body :mass mass :inertia inertia :position (vec x y))))
    (attach-shape (make-circle radius :restitution 0.8 :friction 0.5) body)
    (world-add-body (world demo) body)))

(defun add-poly (demo x y)
  (let* ((mass (* 25 (expt (shape-dimension demo) 2)))
         (size (/ (shape-dimension demo) 2))
         (verts (list (vec size size)
                      (vec size (- size))
                      (vec (- size) (- size))
                      (vec (- size) size)))
         (body (make-body :mass mass :inertia (moment-for-poly mass verts)
                          :position (vec x y))))
    (attach-shape (make-poly verts :friction 0.2 :restitution 0.3) body)
    (world-add-body (world demo) body)))

(defun add-car (demo x y)
  (let* ((mass (shape-dimension demo))
         (radius (/ (shape-dimension demo) 2))
         (inertia (moment-for-circle mass 0 radius))
         (verts (list (vec (+ 5 radius) radius)
                      (vec (+ 5 radius) (- radius))
                      (vec (- radius) (- radius))
                      (vec (- radius) radius)))
         (wheel1 (make-body :mass mass :inertia inertia :position (vec (+ x radius 5) y)))
         (wheel2 (make-body :mass mass :inertia inertia :position (vec (- x radius 5) y)))
         (body (make-body :mass mass :inertia (moment-for-poly mass verts) :position (vec x (+ 5 (shape-dimension demo) y)))))
    (attach-shape (make-circle radius :restitution 0.5 :friction 0.5) wheel1)
    (attach-shape (make-circle radius :restitution 0.5 :friction 0.5) wheel2)
    (attach-shape (make-poly verts :friction 0.5 :restitution 0.5) body)
    (world-add-body (world demo) wheel1)
    (world-add-body (world demo) wheel2)
    (world-add-body (world demo) body)
    (world-add-constraint (world demo) (make-pin-joint wheel1 body (vec 0 0) (vec 0 0)))
    (world-add-constraint (world demo) (make-pin-joint wheel2 body (vec 0 0) (vec 0 0)))
    (world-add-constraint (world demo) (make-pin-joint wheel2 wheel1 (vec 0 0) (vec 0 0)))))

(defreply mouse-down ((engine =squirl-demo=) button)
  (case button
    (0 (grab-object engine))
    (1 (add-poly engine (mouse-x engine) (mouse-y engine)))
    (2 (add-car engine (mouse-x engine) (mouse-y engine)))
    (3 (incf (shape-dimension engine) (shape-dimension-increment engine)))
    (4 (unless (<= (shape-dimension engine)
                   (shape-dimension-increment engine))
         (decf (shape-dimension engine) (shape-dimension-increment engine))))))

(defun grab-object (engine)
  (let* ((point (vec (mouse-x engine) (mouse-y engine)))
         (shape (world-point-query-first (world engine) point)))
    (when shape
      (let ((body (shape-body shape)))
        (setf (mouse-joint engine) (make-pivot-joint (mouse-body engine) body 
                                                     +zero-vector+ (world->body-local body point))
              (squirl::constraint-bias-coefficient (mouse-joint engine)) 0.15)
        (world-add-constraint (world engine) (mouse-joint engine))))))

(defreply mouse-up ((engine =squirl-demo=) button)
  (case button
    (0 (release-object engine))))

(defun release-object (engine)
  (world-remove-constraint (world engine) (mouse-joint engine))
  (setf (mouse-joint engine) nil))

(defreply key-down ((engine =squirl-demo=) key)
  (case key
    (#\] (incf (shape-dimension engine) (shape-dimension-increment engine)))
    (#\[ (unless (<= (shape-dimension engine)
                     (shape-dimension-increment engine))
           (decf (shape-dimension engine)
                 (shape-dimension-increment engine)))))
  (call-next-reply))

(defun run-demo ()
  (run =squirl-demo=))
